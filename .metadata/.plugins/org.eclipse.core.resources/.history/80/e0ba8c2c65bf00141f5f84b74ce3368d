//============================================================================
// Name        : RegDFA.cpp
// Author      : Deverick Simpson
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================
#include "InfixToPostfix.h"
#include <iostream>
#include <stack>
#include <map>
#include <string>
#include <vector>
#include <sstream>  // requires standard library
#include <fstream>  // Note this extra header requirement whenever working with files
#include <cstdlib>
using namespace std;


/*
 * stateId refers to the current state
 * Struct will represent a state node within the NFA
 */
struct State{
	int stateId;

	bool finalState;
};


struct nfaFrag{
	//points to start state for frag
	State *start;
};


State createState(char c){
	State packagedState;

	State *tail;
	return packagedState;
}

void addEmptyEdge(State emptytransition, State toState){

}

void concatEdge(stack<char> fragStack){


}

void kleeneEdge(stack<State> fragStack){
	   State tempState = fragStack.top();
	   fragStack.pop();
	   State tempState1 = fragStack.top();
	   fragStack.pop();
}

void orEdge(stack<char> fragStack){

}


/*
 *
 * Thompsons Construction Algorithm
 * http://swtch.com/~rsc/regexp/regexp1.html
 */

void toNFA(string Postfix){
	//WILL NEED TO CHANGE FOR CSE STANDARDS!!
	std::stack<State> stackOFrags;
	for(char& c : Postfix) {
		   switch ( c ) {
		   	   case 'a':
		   		   stackOFrags.push(createState(c));
		   		 break;
		   	   case 'b':
		   		   stackOFrags.push(createState(c));
		   		 break;
		   	   case '*':
		   		   kleeneEdge(stackOFrags);
		   		 break;
		   	   case '|':
		   		   orEdge(stackOFrags);
		   		 break;
		   	   case '.':
		   		   concatEdge(stackOFrags);
		   		 break;
		   	   default:
		   		 break;
		  }
	}
}



void fileparser(){
	string STRING;
	    ifstream infile;
	    int bIndex=0;
	    string previousLine="";
	   //Change to match homework readme
	    infile.open ("/Users/Deverick/Documents/workspace/RegDFA/Libs/input.txt");

	    while(!infile.eof()) // To get you all the lines.
	    {
	        getline(infile,STRING); // Saves the line in STRING.
	        //Parsing RegEx
	        if(bIndex==0){
	        	//Calling InfixToPostfix File returning a queue
	        	InfixToPostfix sampleTest;
	        	//converToPostfix is a string===remove string creation, wasting space
	        	string postfix = sampleTest.convertToPostfix(sampleTest.addConcat(STRING));
	        	int lengthOF = postfix.size();
	        	toNFA(postfix);

	        }
	        //ONE EXTRA TEST CASE IS BEING RAN~~REMOVE--I added 1 to check on bIndex..check that
	        //Testing String Input against cases
	        //cout<<"The test case is: "<<endl;
	        if(bIndex>1){
	        	// cout<<STRING<<endl; // Prints our STRING.
	        }

	        bIndex++;
	    }
	    infile.close();
	    cout<<"We are here "<<endl;
	    //Need to return a parsing stack to manipulate the regex to a NFA
}





int main(){
	char Name[30];
	cout << "!!!Hello, what is your name!!!" << endl; // prints !!!Hello World!!!
	cin >> Name;
	ifstream ifs( "/Users/Deverick/Documents/workspace/RegDFA/Libs/input.txt" );       // note no mode needed
	   if ( ! ifs.is_open() ) {
		   cout << "Hello,"<< Name << " we have failed to open the file, check the path"<< endl;
	   }
	   else {
		   cout << "Hello, "<< Name <<" All seems to be running smooth...Here's the parsing of the file"<< endl;
		   fileparser();
	   }
	   cout<< "Closing Down"<< endl;
	return 0;
}
